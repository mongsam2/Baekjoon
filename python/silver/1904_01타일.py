'''
2진 수열 중에서 0은 두 개씩 붙은(00)경우만 만들 수 있다.

input: N(1~1,000,000)
output: 만들 수 있는 길이가 N인 수열 % 15746

           0     1
  1            00    2
11 100       001 0000     3

algorithm:
-------------------------------
n = input()
count=0
def tile(length):
    if length==n:
        count+=1
    if length+2<=n:
        tile(length+2)
    if length+1<=n:
        tile(length+1)
-------------------------------
이미 완성된 숫자 타일들을 이어붙여 더 큰 자리의 수열 패널을 만드는 개념
lst[n]: n 자리수의 가능한 수열의 개수
n자리의 수열의 개수 lst[n]:
1. n이 짝수일 때: lst[n/2] C 2
2. n이 홀수일 때: lst[n//2]*lst[n//2+1]*2

1  
00 11
100 001 111 
1100 (0011) 1001 1111 +0000
11100 (00111) 10011 11001 11111 10000 (00001) 00100
000000 110000 000011 100001 001100 100100 001001 111100 001111 110011 100111 111001 111111

1 2 3 5 8
tile(n) = tile(n-1) + tile(n-1)

*메모리초과문제: [0]*n으로 배열을 선언하지 않고 3개의 변수를 리스트를 이용해 사용했다.
*시간초과문제: 저장되는 숫자가 커질수록 메모리도 커지고 숫자를 옮기는 연산도 오래 걸릴 것이라고 생각했다.
'''
n = int(input()) # 수열의 길이
num_lst = [0, 2, 1] # n[0]: n / n[1]: n1 / n[2]: n2 --> n = n1 + n2
def tile_count(n): # 피보나치 함수
    if n==1:
        return 1
    elif n==2:
        return 2
    for i in range(3, n+1): # 3번째 부터 n번째까지 bottom up 방식으로 n번째 피보나치 수를 구한다.
        num_lst[0] = (num_lst[1] + num_lst[2])%15746 # ** 모듈러 연산 분배법칙!ㄷ --> (a+b)%m = a%m + b%m
        num_lst[2] = num_lst[1] # n1과 n2를 업데이트
        num_lst[1] = num_lst[0]
    return num_lst[0]
print(tile_count(n))
